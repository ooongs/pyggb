# DSL Quick Reference Guide

## Basic Syntax

Every DSL line follows: `command : inputs -> outputs`

## Commands by Category

### 1. Points
```
point :  -> A                    # Random point
point : 100 150 -> P             # Fixed coordinates (x, y) - inline numeric literals!
point : 0 0 -> Origin            # Integer coordinates
point : 50.5 86.7 -> P           # Float coordinates (precision preserved!)
point : mx my -> P               # From measure variables
point : circle -> P              # Random point on circle
point : line -> P                # Random point on line
```

**Note**: 
- Numeric literals with decimals are stored as `float` (e.g., `50.5`)
- Numeric literals without decimals are stored as `int` (e.g., `100`)
- Both work seamlessly with geometric functions
- For `Measure` type, use explicit `const Measure X -> label`

### 2. Lines
```
line : A B -> line_AB            # Line through two points
line_bisector : A B -> bisector  # Perpendicular bisector
```

### 3. Segments
```
segment : A B -> seg_AB          # Segment from A to B
```

### 4. Rays
```
ray : A B -> ray_AB              # Ray from A through B
```

### 5. Circles
```
circle : O A -> circle_O         # Center O, passes through A
circle : O radius -> circle_O    # Center O, radius (variable)
circle : O 50 -> circle_O        # Center O, radius 50 (inline literal)
```

### 6. Polygons
```
polygon : A B C -> poly1 c a b   # Triangle (poly + sides)
polygon : A B C D -> poly1 d c b a  # Quad (poly + sides)
```

### 7. Angles
```
angle : A B C -> angle_ABC       # Angle at B from A to C
const int 90 -> deg              # Angle value
```

### 8. Rotations
```
rotate : P deg Center -> P_rot   # Rotate P by deg around Center
rotate : P angle Center -> P_rot # Rotate by angle object

# How to write angles:
rotate : P 90° Center -> P_rot   # 90 degrees (degree)
rotate : P 45.5° Center -> Q     # 45.5 degrees (degree)
rotate : P 1.5708rad Center -> Q # 1.5708 radians (radian)
rotate : P 1.5708r Center -> Q   # short notation (r = radian)
rotate : P 90 Center -> Q        # general number = degree (default)
```

**Angle notation rules**:
- `90°` → degree (degree unit)
- `1.5708rad` → radian (radian unit)
- `1.5708r` → radian (short notation)
- `90` → degree (default, backward compatibility)

### 9. Intersections
```
intersect : line1 line2 -> P     # Intersection of two lines
intersect : line circle -> P     # Line-circle (may return 2 points)
```

### 10. Perpendicular/Parallel
```
orthogonal_line : P line -> perp    # Perpendicular line through P
parallel_line : P line -> para      # Parallel line through P
parallel_line : P segment -> para   # Parallel to segment through P
parallel_line : P ray -> para       # Parallel to ray through P
```

### 11. Midpoints
```
midpoint : A B -> M              # Midpoint of segment AB
```

### 12. Measurements & Constants
```
distance : A B -> dist           # Distance between points
const int 50 -> value            # Integer constant (explicit)
const Measure 10 -> length       # Measure constant (explicit)

# OR use inline numeric literals (precision preserved):
point : 100 200 -> P             # Integers: 100, 200
point : 50.5 86.7 -> Q           # Floats: 50.5, 86.7 (precision preserved!)
circle : O 30.5 -> c             # Float radius: 30.5

# Inline angles with units:
rotate : P 90° Center -> Q       # 90 degrees (° symbol)
rotate : P 45.5° Center -> R     # 45.5 degrees (precision preserved!)
rotate : P 1.5708rad Center -> S # 1.5708 radians (explicit radian)
rotate : P 90 Center -> T        # 90 degrees (default = degree)
```

### 12.1 Trigonometric Functions (NEW!)
```
# Use cos(), sin(), tan() with degree or radian values as inline literals
# Default is degree (like angle notation)

# Degree notation (° or deg):
point : cos(30°) sin(30°) -> A     # Point at (cos(30°), sin(30°)) ≈ (0.866, 0.5)
point : cos(60°) sin(60°) -> B     # Point at (cos(60°), sin(60°)) ≈ (0.5, 0.866)
point : cos(45deg) sin(45deg) -> C # Same as cos(45°) sin(45°)

# Radian notation (rad or r):
point : cos(1.5708rad) sin(1.5708rad) -> D  # cos(π/2), sin(π/2) ≈ (0, 1)
point : cos(0.5236r) sin(0.5236r) -> E      # cos(30° in rad), sin(30° in rad)

# Default (no unit = degree):
point : cos(30) sin(30) -> F       # Same as cos(30°) sin(30°)

# Scale with multiplication:
# To create point at distance r from origin with angle θ:
# x = r * cos(θ), y = r * sin(θ)
# Use arithmetic commands:
const Measure 100 -> r
const Measure 0.866 -> cos30       # cos(30°) ≈ 0.866
const Measure 0.5 -> sin30         # sin(30°) ≈ 0.5
product : r cos30 -> x
product : r sin30 -> y
point : x y -> P                   # Point at distance 100, angle 30°

# OR more directly (inline trig):
point : 0 0 -> Origin
point : cos(30°) sin(30°) -> UnitP  # Unit circle point
# Then scale...
```

**Common Trigonometric Values (for reference):**
| Angle | cos | sin | tan |
|-------|-----|-----|-----|
| 0°    | 1   | 0   | 0   |
| 30°   | √3/2 ≈ 0.866 | 1/2 = 0.5 | 1/√3 ≈ 0.577 |
| 45°   | √2/2 ≈ 0.707 | √2/2 ≈ 0.707 | 1 |
| 60°   | 1/2 = 0.5 | √3/2 ≈ 0.866 | √3 ≈ 1.732 |
| 90°   | 0   | 1   | undefined |

**Use cases:**
- Creating points on unit circle
- Calculating coordinates with angles
- Positioning points at specific angles from origin

### 13. Arithmetic
```
sum : a b -> c                   # Addition
minus : a b -> c                 # Subtraction
product : a b -> c               # Multiplication
ratio : a b -> c                 # Division
```

### 14. Verification (OPTIONAL)
```
equality : A A -> expr0          # Optional equality check
prove : expr0 -> result          # Optional prove statement
```

**Note**: These lines are OPTIONAL and not required for basic constructions.

### 15. IMPORTANT CONSTRAINTS

**What DSL CAN do:**
- ✅ Construct points, lines, circles, polygons
- ✅ Transform objects (rotate, mirror, etc.)
- ✅ Find intersections, midpoints
- ✅ Create geometric objects

**What DSL CANNOT do:**
- ❌ Assert angle values: `equality : angle_A 80` (WRONG!)
- ❌ Assert parallel: `parallel : line1 line2` (WRONG!)
- ❌ Assert perpendicular: `perpendicular : line1 line2` (WRONG!)
- ❌ Directly enforce constraints

**How to handle constraints:**
- If problem says "angle A = 80°", construct the geometry to naturally have that angle (use `rotate` command)
- If problem says "AB∥CD", construct parallel lines using `parallel_line` command
- If problem says "AB⊥CD", use `orthogonal_line` command to construct perpendicular

## Validation-Friendly Patterns

### Pattern 1: Explicitly Create Mentioned Objects

If problem mentions specific geometric objects, create them explicitly:

```
# Problem mentions "segment AB" and "segment BC"
point :  -> A
point :  -> B
point :  -> C
segment : A B -> seg_AB    # Explicitly create
segment : B C -> seg_BC    # Explicitly create
```

### Pattern 2: Points on Segments

If problem says "D is on AB":

```
# Method 1: Fixed coordinates (if A and B are fixed)
point : 0 0 -> A
point : 200 0 -> B
point : 80 0 -> D          # D between A and B on x-axis

# Method 2: Using intersection with another line
point :  -> A
point :  -> B
line : A B -> line_AB
# ... construct another line that intersects AB
intersect : line_AB other_line -> D
```

### Pattern 3: Parallel Lines

If problem says "DE∥BC":

```
# Method 1: Use parallel_line command (RECOMMENDED)
point :  -> B
point :  -> C
line : B C -> line_BC
point :  -> D
parallel_line : D line_BC -> line_DE
# Now line_DE passes through D and is parallel to BC

# Method 2: Create second point E on the parallel line
point :  -> B
point :  -> C
segment : B C -> seg_BC
point :  -> D
parallel_line : D seg_BC -> line_DE
point : line_DE -> E
# Now line DE is parallel to BC

# Method 3: Use rotation (for equal-length parallel segments)
point :  -> B
point :  -> C
vector : B C -> vec_BC
point :  -> D
translate : D vec_BC -> E
# Now DE is parallel to BC and has same length
```

### Pattern 4: Creating Triangles

Always use polygon command for triangles:

```
point :  -> A
point :  -> B
point :  -> C
polygon : A B C -> triangle side_c side_a side_b
```

This creates:
- `triangle`: the polygon object
- `side_c`, `side_a`, `side_b`: the three sides (in reverse order!)

### Pattern 5: Angles with Specific Values

```
# Create angle of 60° using rotation
point : 0 0 -> A
point : 100 0 -> B
rotate : B 60° A -> C
# Now angle CAB = 60°
```

### Validation Checklist:

Before finalizing your DSL, check:
- [ ] All points mentioned in problem are created
- [ ] All segments mentioned in problem are created (or points exist)
- [ ] All lines mentioned in problem are created (or points exist)
- [ ] All polygons mentioned in problem are created explicitly
- [ ] All circles mentioned in problem are created explicitly
- [ ] Conditions (parallel, perpendicular, angles) are satisfied geometrically
- [ ] Points "on segments/lines" are positioned correctly
- [ ] DSL ends with prove statement (equality : A A -> expr0, prove : expr0 -> result)

## Common Patterns

### Creating Parallel Lines:
```
# Method 1: Using parallel_line command (RECOMMENDED)
point :  -> A
point :  -> B
line : A B -> line_AB
point :  -> C
parallel_line : C line_AB -> line_CD
# line_CD passes through C and is parallel to line_AB

# Method 2: With segments
point :  -> A
point :  -> B
segment : A B -> seg_AB
point :  -> C
parallel_line : C seg_AB -> line_CD
```

### Creating Perpendicular Lines:
```
point :  -> A
point :  -> B
line : A B -> line_AB
point :  -> C
orthogonal_line : C line_AB -> perp_line
```

### Creating a Triangle:
```
point :  -> A
point :  -> B
point :  -> C
polygon : A B C -> triangle side_c side_a side_b
```

### Angle Bisector:
```
angle : A B C -> angle_ABC
angular_bisector : A B C -> bisector
```

### Rotating a Point:
```
point :  -> Center
const int 60 -> deg
point :  -> P
rotate : P deg Center -> P_rotated
```

## Critical Rules

1. **Order matters**: Define objects before using them
2. **Labels**: Use descriptive names (Center, line_AB, not x, y, z)
3. **Outputs**: Polygon command outputs: polygon, then sides in reverse order
4. **Random vs Fixed**: Use `point :  -> A` for unconstrained points

## Common Errors

❌ **Using undefined object**:
```
line : A B -> line_AB  # Error: A and B not defined
```

✅ **Correct**:
```
point :  -> A
point :  -> B
line : A B -> line_AB
```

❌ **Using undefined object**:
```
circle : O 50 -> c  # Error: O not defined
```

✅ **Correct**:
```
point :  -> O
circle : O 50 -> c
```

❌ **Wrong output count**:
```
polygon : A B C -> triangle  # Error: polygon outputs 4 things
```

✅ **Correct**:
```
polygon : A B C -> triangle side_c side_a side_b
```

